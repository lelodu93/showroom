# -*- coding: utf-8 -*-
"""streamlit_demo.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H2bj8Gdm4kMGtdvHtTz66xNLvzI7wRaX
"""

import pandas as pd

df = pd.read_excel("hetic-showroom-5mars.xlsx")

import subprocess
import sys

def install(package):
    subprocess.check_call([sys.executable, "-m", "pip", "install", package])

# Installe les bibliothèques nécessaires
install("streamlit")
install("pandas")
install("plotly")
install("matplotlib")
install("wordcloud")

import subprocess
import sys

def install(package):
    subprocess.check_call([sys.executable, "-m", "pip", "install", package])

# Installe les bibliothèques nécessaires
install("streamlit")
install("pandas")
install("plotly")
install("matplotlib")
install("wordcloud")
import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import plotly.express as px
from wordcloud import WordCloud

# Titre du tableau de bord
st.title("Analyse des avis clients - Showroomprive")
st.write("Ce tableau de bord permet d'analyser les avis clients collectés sur le Google Play Store.")

# Chargement des données
@st.cache_data
def load_data():
    return pd.read_excel("hetic-showroom-5mars.xlsx")

data = load_data()
# Filtres interactifs
st.sidebar.header("Filtres")
sentiment_filter = st.sidebar.multiselect("Filtrer par sentiment", options=data['Sentiment'].unique(), default=data['Sentiment'].unique())

# Application des filtres
filtered_data = data[data['Sentiment'].isin(sentiment_filter)]

# Affichage des KPI
st.header("Indicateurs clés de performance (KPI)")
col1, col2 = st.columns(2)
with col1:
    st.metric("Nombre total d'avis", len(filtered_data))
with col2:
    st.metric("Pourcentage d'avis positifs", f"{len(filtered_data[filtered_data['Sentiment'] == 'positif']) / len(filtered_data) * 100:.2f}%")

# Graphique des sentiments
st.header("Répartition des sentiments")
sentiment_counts = filtered_data['Sentiment'].value_counts()
fig, ax = plt.subplots()
ax.pie(sentiment_counts, labels=sentiment_counts.index, autopct='%1.1f%%', startangle=90)
ax.axis('equal')
st.pyplot(fig)

# Graphique en barres pour les scores
st.header("Distribution des notes (scores)")
score_counts = filtered_data['score'].value_counts().sort_index()
fig_score = px.bar(score_counts, x=score_counts.index, y=score_counts.values, labels={'x': 'Score', 'y': 'Nombre d\'avis'})
st.plotly_chart(fig_score)
# Filtre les valeurs non textuelles dans la colonne 'avis'
filtered_reviews = filtered_data['avis'].dropna().astype(str)

# Nuage de mots
st.header("Nuage de mots des avis")
text = " ".join(review for review in filtered_reviews)
wordcloud = WordCloud(background_color="white", width=800, height=400).generate(text)
fig_wordcloud, ax = plt.subplots()
ax.imshow(wordcloud, interpolation='bilinear')
ax.axis('off')
st.pyplot(fig_wordcloud)

# Graphique en camembert pour la subjectivité
st.header("Répartition de la subjectivité")
subjectivity_counts = filtered_data['Subjectivité'].value_counts()
fig_subjectivity = px.pie(subjectivity_counts, values=subjectivity_counts.values, names=subjectivity_counts.index, title="Subjectivité des avis")
st.plotly_chart(fig_subjectivity)

# Graphique temporel
st.header("Évolution des avis dans le temps")
if 'date_only' in filtered_data.columns:
    filtered_data['date_only'] = pd.to_datetime(filtered_data['date_only'])
    time_series = filtered_data.groupby('date_only').size()
    fig_time = px.line(time_series, x=time_series.index, y=time_series.values, labels={'x': 'Date', 'y': 'Nombre d\'avis'})
    st.plotly_chart(fig_time)
else:
    st.write("La colonne 'date_only' n'est pas disponible pour l'analyse temporelle.")

# Tableau interactif avec coloration
st.header("Tableau des avis avec coloration")
def color_sentiment(val):
    color = 'green' if val == 'positif' else 'red' if val == 'negatif' else 'gray'
    return f'background-color: {color}'

styled_table = filtered_data[['avis', 'Sentiment', 'date_only', 'score', 'Subjectivité']].style.applymap(color_sentiment, subset=['Sentiment'])
st.dataframe(styled_table)

#a voir ce que l'on prend!!
import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import plotly.express as px
from wordcloud import WordCloud

# Titre du tableau de bord
st.title("Analyse des avis clients - Showroomprive")
st.write("Ce tableau de bord permet d'analyser les avis clients collectés sur le Google Play Store.")

# Chargement des données
@st.cache_data
def load_data():
    return pd.read_excel("/content/hetic-showroom-5mars.xlsx")

data = load_data()

# Filtres interactifs
st.sidebar.header("Filtres")
sentiment_filter = st.sidebar.multiselect("Filtrer par sentiment", options=data['Sentiment'].unique(), default=data['Sentiment'].unique())

# Application des filtres
filtered_data = data[data['Sentiment'].isin(sentiment_filter)]

# Affichage des KPI
st.header("Indicateurs clés de performance (KPI)")
col1, col2 = st.columns(2)
with col1:
    st.metric("Nombre total d'avis", len(filtered_data))
with col2:
    st.metric("Pourcentage d'avis positifs", f"{len(filtered_data[filtered_data['Sentiment'] == 'positif']) / len(filtered_data) * 100:.2f}%")

# Graphique des sentiments
st.header("Répartition des sentiments")
sentiment_counts = filtered_data['Sentiment'].value_counts()
fig, ax = plt.subplots()
ax.pie(sentiment_counts, labels=sentiment_counts.index, autopct='%1.1f%%', startangle=90)
ax.axis('equal')
st.pyplot(fig)

# Graphique en barres pour les scores
if 'score' in filtered_data.columns:
    st.header("Distribution des notes (scores)")
    score_counts = filtered_data['score'].value_counts().sort_index()
    fig_score = px.bar(score_counts, x=score_counts.index, y=score_counts.values, labels={'x': 'Score', 'y': 'Nombre d\'avis'})
    st.plotly_chart(fig_score)
else:
    st.write("La colonne 'score' n'est pas disponible.")

# Nuage de mots
st.header("Nuage de mots des avis")
text = " ".join(review for review in data['avis'])
wordcloud = WordCloud(background_color="white", width=800, height=400).generate(text)
fig_wordcloud, ax = plt.subplots()
ax.imshow(wordcloud, interpolation='bilinear') # Corrected line
ax.axis('off')
st.pyplot(fig_wordcloud)

# ... (rest of the code remains the same)
